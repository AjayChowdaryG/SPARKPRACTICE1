object P28 {
def lsort[T](list: List[List[T]]): List[List[T]] = list.sortBy(_.length)
def lfsort[T](list: List[List[T]]): List[List[T]] =lsort(list)
      .groupBy(_.length).values.toList
      .sortBy(_.length)
      .flatten
}

def primes: Stream[Long] = 2 #:: prime3

	private val prime3: Stream[Long] = {
	    def next(i: Long): Stream[Long] =
	      if (prime(i))
	        i #:: next(i + 2)
	      else
	        next(i + 2) // tail
	    3 #:: next(5)
	  }
	  
	    private def prime(i: Long) =
	    prime3 takeWhile (math.sqrt(i).>= _) forall { i % _ != 0 }


object P02 {

  def secondLast[T](list: List[T]): T = list match {
    case x :: (_ :: Nil) => x
    case x :: xs => secondLast(xs)
    case _ => throw new NoSuchElementException("Can't find secondLast element from a list with less than 2 elements")
  }
  def secondLast1[T](list: List[T]): T = if (list.isEmpty) throw new NoSuchElementException else list.init.last
}
	it("should give second last element when list has more than two elements") {
	  val numbers = List(1, 2, 11, 4, 5, 8, 10, 6)
	  P02.secondLast(numbers) should be(10)
	}


/**
  * Reverse a list
  */
object P05 {
  def reverse[T](list: List[T]): List[T] = list.reverse

  def reverseRecursive[T](list: List[T]): List[T] = {
    @tailrec
    def tail(src: List[T], dest: List[T]): List[T] = src match {
      case Nil => dest
      case x :: xs => tail(xs, x +: dest)
    }
    tail(list, List())
  }
}
	it("should reverse a list") {
	  P05.reverse(List(1, 2, 3, 4, 5)) should equal(List(5, 4, 3, 2, 1))
	}

/**
  * Find out whether a list is a palindrome
  */
object P06 {
  def isPalindrome[T](list: List[T]): Boolean = {
    P05.reverse(list) == list
  }
  def isPalindrome_reverseRecursive[T](list: List[T]): Boolean = {
    P05.reverseRecursive(list) == list
  }
}
it("should return true when list is palindrome") {
	  P06.isPalindrome(List("x", "a", "m", "a", "x")) should be(true)
	}
	
	it("should return false when list is not palindrome") {
	  P06.isPalindrome(List(1, 2, 3, 4, 5)) should be(false)
	}


